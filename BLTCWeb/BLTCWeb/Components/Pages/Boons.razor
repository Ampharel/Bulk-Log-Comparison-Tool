@page "/boons"
@using System.Net.Http.Json
@using MudBlazor
@using MudBlazor.Components.Chart.Models
@using Bulk_Log_Comparison_Tool.Util;
@rendermode InteractiveServer

<h3>Boons</h3>

@inject ServerParser LogParser
<LogDrawer OnUpload="StateHasChanged" />


<div style="overflow-x: auto;">

    <div>
        <MudButtonGroup Color="Color.Primary" Variant="Variant.Outlined">
            @if(_selectedPhase== "")
            {
                <MudButton>Phase</MudButton>
            }
            else
            {
                <MudButton>@_selectedPhase</MudButton>
            }
                <MudMenu Icon="@Icons.Material.Filled.ArrowDropDown" Style="align-self: auto;">
                    @foreach (var log in LogParser.BulkLog.GetPhases())
                {
                    <MudMenuItem OnClick="() => SetPhase(log)">@log</MudMenuItem>
                }
            </MudMenu>
        </MudButtonGroup>
        <MudButtonGroup Color="Color.Primary" Variant="Variant.Outlined">
            <MudButton>@CDMToString(_chartDisplayMode)</MudButton>
                <MudMenu Icon="@Icons.Material.Filled.ArrowDropDown" Style="align-self: auto;">
                    <MudMenuItem OnClick="() => SetMode(ChartDisplayMode.GraphPerLog)">Graph Per Log</MudMenuItem>
                    <MudMenuItem OnClick="() => SetMode(ChartDisplayMode.GraphPerPlayer )">Graph Per Player</MudMenuItem>
                    <MudMenuItem OnClick="() => SetMode(ChartDisplayMode.LostTimings)">Boon lost timings</MudMenuItem>
            </MudMenu>
        </MudButtonGroup>
            <MudCheckBox Value="@_showPlayers" ValueChanged="ShowPlayersChanged" Color="Color.Primary">Players</MudCheckBox>
            <MudCard>
                <MudCardContent>
                @foreach (var group in LogParser.BulkLog.GetGroups())
                {
                    <MudItem>
                        <MudText>Group @group</MudText>
                        </MudItem>
                <MudGrid>
                    @foreach (var player in _showPlayersDict)
                    {
                    if (LogParser.IsPlayerInGroup(player.Key, group))
                    {
                        <MudItem>
                            <MudCheckBox T="bool" Value="@player.Value" ValueChanged="(isChecked) => UpdateShowPlayer(player.Key, isChecked)" Color="Color.Primary">@player.Key</MudCheckBox>
                            </MudItem>
                    }
                }
                </MudGrid>
            }
                </MudCardContent>
            </MudCard>

        <MudCheckBox Value="@_showGroups" ValueChanged="ShowGroupsChanged" Color="Color.Primary">Groups</MudCheckBox>            
        <MudGrid>
            @foreach (var group in _showGroupsDict)
            {
                <MudItem>
                    <MudCheckBox T="bool" Value="@group.Value" ValueChanged="(isChecked) => UpdateShowGroup(group.Key, isChecked)" Color="Color.Primary">@group.Key</MudCheckBox>
                </MudItem>
            }
        </MudGrid>
            <MudRadioGroup Value="@_selectedBoon" ValueChanged="SelectedBoonChanged">
            @foreach (var boonName in LogParser.BulkLog.GetBoonNames())
            {
                <MudRadio Value="@boonName" Color="Color.Primary">@boonName</MudRadio>
            }
        </MudRadioGroup>
    </div>
    @if (_chartDisplayMode == ChartDisplayMode.GraphPerLog)
    {
        <MudTable Items="@LogParser.BulkLog.Logs"
                  Hover="true"
                  Breakpoint="Breakpoint.Sm"
                  LoadingProgressColor="Color.Info"
                  Class="flex-table">
            <HeaderContent>
                <MudTh>File</MudTh>
                <MudTh>Graph</MudTh>
            </HeaderContent>
            <RowTemplate>
                @{
                    if (Series.Count() == 0)
                    {
                        OnNewData();
                    }
                    var data = Series[context.GetFileName()];
                }
                <MudTd>@context.GetFileName()</MudTd>
                    <MudTimeSeriesChart ChartType="ChartType.Line"  TimeLabelFormat="mm:ss" ChartSeries="@data" @bind-SelectedIndex="Index" TimeLabelSpacing="@graphTimespan" CanHideSeries Width="100%" Height="350px" ChartOptions="@Options" />
             </RowTemplate>
         </MudTable>
    }
    else if(_chartDisplayMode == ChartDisplayMode.GraphPerPlayer)
    {
        <MudTable Items="@LogParser.BulkLog.GetPlayers()"
                  Hover="true"
                  Breakpoint="Breakpoint.Sm"
                  LoadingProgressColor="Color.Info"
                  Class="flex-table">
            <HeaderContent>
                <MudTh>File</MudTh>
                <MudTh>Graph</MudTh>
            </HeaderContent>
            <RowTemplate>
                @{
                    var data = Series[context];
                }
                <MudTd>@context</MudTd>
                    <MudTimeSeriesChart ChartType="ChartType.Line" TimeLabelFormat="mm:ss" TimeLabelSpacing="@graphTimespan" ChartSeries="@data" @bind-SelectedIndex="Index" CanHideSeries Width="100%" Height="350px" ChartOptions="@Options" />
             </RowTemplate>
         </MudTable>
    }
    else if(_chartDisplayMode == ChartDisplayMode.LostTimings)
    {
        <MudTable Items="@LogParser.BulkLog.GetPlayers()"
                  Hover="true"
                  Breakpoint="Breakpoint.Sm"
                  LoadingProgressColor="Color.Info"
                  Class="flex-table">
            <HeaderContent>
                @foreach(var log in @LogParser.BulkLog.Logs)
                {
                    <MudTh>@log.GetFileName()</MudTh>
                }
            </HeaderContent>
            <RowTemplate>
                <MudTd>@context</MudTd>

                @foreach(var log in @LogParser.BulkLog.Logs)
                {
                    if (_buffLostTimings.ContainsKey(log.GetFileName()) && _buffLostTimings[log.GetFileName()].ContainsKey(context))
                    {
                        <MudTd>@_buffLostTimings[log.GetFileName()][context]
                        </MudTd>
                    }
                }
             </RowTemplate>
         </MudTable>
    }
</div>

@code {

    private int Index = -1; //default value cannot be 0 -> first selectedindex is 0.
    public ChartOptions Options = new ChartOptions();

    private enum ChartDisplayMode
    {
        GraphPerLog,
        GraphPerPlayer,
        LostTimings
    }
    private ChartDisplayMode _chartDisplayMode = ChartDisplayMode.GraphPerLog;
    public Dictionary<string, List<TimeSeriesChartSeries>> Series = new();
    private Dictionary<string, Dictionary<string, string>> _buffLostTimings = new Dictionary<string, Dictionary<string, string>>();
    public string[] XAxisLabels = {};
    private string _selectedBoon = "Might";
    private string _selectedPhase = "";
    private bool _showPlayers = true;
    private bool _showGroups = false;
    public EventCallback<string> SelectedBoonChanged;
    public EventCallback<bool> ShowPlayersChanged;
    public EventCallback<string> ShowPlayerChanged;
    public EventCallback<bool> ShowGroupsChanged;
    public EventCallback<string> ShowGroupChanged;

    private TimeSpan graphTimespan;

    private Dictionary<string, bool> _showPlayersDict = new();
    private Dictionary<string, bool> _showGroupsDict = new();

    private Dictionary<string, string> _playerColours = new();
    private string[] Colours = 
    {
            Colors.Blue.Accent3, Colors.Teal.Accent3, Colors.Amber.Accent3, Colors.Orange.Accent3, Colors.Red.Accent3,
            Colors.DeepPurple.Accent3, Colors.Green.Accent3, Colors.LightBlue.Accent3, Colors.Teal.Lighten1, Colors.Amber.Lighten1,
            Colors.Orange.Lighten1, Colors.Red.Lighten1, Colors.DeepPurple.Lighten1, Colors.Green.Lighten1, Colors.LightBlue.Lighten1,
            Colors.Amber.Darken2, Colors.Orange.Darken2, Colors.Red.Darken2, Colors.DeepPurple.Darken2, Colors.Gray.Darken2
    };

    private TimeSpan _graphSpacing = TimeSpan.FromSeconds(30);

    private string CDMToString(ChartDisplayMode cdm)
    {
        return cdm switch
        {
            ChartDisplayMode.GraphPerLog => "Graph Per Log",
            ChartDisplayMode.GraphPerPlayer => "Graph Per Player",
            ChartDisplayMode.LostTimings => "Lost Timings",
            _ => "Unknown"
        };
    }

    private void OnNewData()
    {
        Console.WriteLine("New data stopwatch start");
        LogParser.StartStopwatch();
        foreach(var player in LogParser.BulkLog.GetPlayers()){
            if (!_showPlayersDict.ContainsKey(player))
                _showPlayersDict.Add(player, true);
            if (!_playerColours.ContainsKey(player))
                _playerColours.Add(player, Colours[_playerColours.Count % Colours.Length]);
        }
        foreach(var group in LogParser.BulkLog.GetGroups()){
            if (!_showGroupsDict.ContainsKey(group.ToString()))
                _showGroupsDict.Add(group.ToString(), false);
        }
        Series = new();
        _buffLostTimings = new();
        List<string> xDataLabel = new();
        var maxTime = 0L;
        var minTime = long.MaxValue; 
        var maxStack = 25;

        Console.WriteLine($"Pre loop stopwatch {LogParser.GetStopwatchTime()}");
        foreach (var Log in LogParser.BulkLog.Logs)
        {
            Console.WriteLine($"Starting log {Log.GetFileName()}");
            _buffLostTimings.Add(Log.GetFileName(), new Dictionary<string, string>());
            if (_chartDisplayMode == ChartDisplayMode.GraphPerLog){
                Series.Add(Log.GetFileName(), new List<TimeSeriesChartSeries>());
            }
            var boonStackType = Log.GetBoonStackType(_selectedBoon);
            var duration = (boonStackType == BuffStackTyping.Queue || boonStackType == BuffStackTyping.Regeneration) ? true : false;

            if (duration)
            {
                maxStack = 30;
                if(_selectedBoon == "Swiftness")
                {
                    maxStack = 60;
                }
            }
            if (_showPlayers)
            {
                Console.WriteLine($"Showing players {LogParser.GetStopwatchTime()}");
                foreach (var Player in Log.GetPlayers())
                {
                    if (_showPlayersDict.ContainsKey(Player) && !_showPlayersDict[Player])
                    {
                        continue;
                    }
                    if (!_buffLostTimings[Log.GetFileName()].ContainsKey(Player))
                    {
                        _buffLostTimings[Log.GetFileName()].Add(Player, "");
                    }
                    if (_chartDisplayMode != ChartDisplayMode.GraphPerLog && !Series.ContainsKey(Player))
                    {
                        Series.Add(Player, new List<TimeSeriesChartSeries>());
                    }
                    List<TimeSeriesChartSeries.TimeValue> chartData = new List<TimeSeriesChartSeries.TimeValue>();

                    var boonEvents = Log.GetBoonTimedEvents(Player, _selectedBoon, _selectedPhase);
                    foreach (var boonEvent in boonEvents)
                    {
                        Console.WriteLine($"Time is {boonEvent.Item1 * 10000L}");
                        if(boonEvent.Item1 < 0)
                        {
                            continue;
                        }
                        chartData.Add(new TimeSeriesChartSeries.TimeValue(new DateTime((long)boonEvent.Item1 * 10000L), boonEvent.Item2 > maxStack ? maxStack : boonEvent.Item2));
                        if(boonEvent.Item2 == 0){
                            _buffLostTimings[Log.GetFileName()][Player] += ("" + (boonEvent.Item1).ToString("0.##") + " ");
                        }
                    }
                    // for (long i = Log.GetPhaseStart(_selectedPhase); i < Log.GetPhaseEnd(_selectedPhase); i += 1000)
                    // {
                    //     var boonAtTime = (int)Log.GetBoon(Player, _selectedBoon, _selectedPhase, i, duration);
                    //     if(boonAtTime == 0 && hasBuff){
                    //         hasBuff = false;
                    //         _buffLostTimings[Log.GetFileName()][Player] += ("" + (i / 1000f).ToString("0.##") + " ");
                    //     }
                    //     else if(boonAtTime > 0){
                    //         hasBuff = true;
                    //     }
                    //     chartData.Add(new TimeSeriesChartSeries.TimeValue(new DateTime(i * 10000), boonAtTime));
                    // }
                    _graphSpacing = TimeSpan.FromSeconds(Math.Round(chartData.Select(x => x.DateTime.Ticks).Max()/100000L * 1.0f)*10);
                    if (_chartDisplayMode == ChartDisplayMode.GraphPerLog)
                    {
                        var chartSeries = new TimeSeriesChartSeries() { Name = Player, Data = chartData, Type = TimeSeriesDiplayType.Line };
                        Console.WriteLine($"Log: {Log.GetFileName()}");
                        Series[Log.GetFileName()].Add(chartSeries);
                    }
                    else
                    {
                        var chartSeries = new TimeSeriesChartSeries() { Name = Log.GetFileName(), Data = chartData, Type = TimeSeriesDiplayType.Line };
                        Console.WriteLine($"Player: {Player}");
                        Series[Player].Add(chartSeries);
                    }
                }
                Console.WriteLine($"Player loop stopwatch {LogParser.GetStopwatchTime()}");
            }
            if (_showGroups)
            {
                Console.WriteLine($"Showing groups {LogParser.GetStopwatchTime()}");
                foreach (var Group in Log.GetGroups())
                {
                    if (!_showGroupsDict.ContainsKey(Group.ToString()) || !_showGroupsDict[Group.ToString()])
                    {
                        continue;
                    }
                    List<(double,double)> boonEvents = new();
                    foreach (var Player in Log.GetPlayers().Where(x => Log.IsPlayerInGroup(x, Group)))
                    {
                        if(_showPlayersDict.ContainsKey(Player) && !_showPlayersDict[Player]){
                            continue;
                        }
                        boonEvents.AddRange(Log.GetBoonTimedEvents(Player, _selectedBoon, _selectedPhase));
                    }
                    if(boonEvents.Count == 0){
                        continue;
                    }
                    boonEvents = boonEvents.DistinctBy(x => x.Item1).OrderBy(x => x.Item1).ToList();

                    var groupEvents = new List<(double,double)>();
                    foreach(var boonEvent in boonEvents)
                    {
                        var time = boonEvent.Item1;
                        var boonTime = 0d;
                        var playerCount = 0;
                        foreach (var Player in Log.GetPlayers().Where(x => Log.IsPlayerInGroup(x,Group)))
                        {
                            boonTime += Log.GetBoon(Player, _selectedBoon, _selectedPhase, (long)time, duration);
                            playerCount++;
                        }
                        groupEvents.Add((time, boonTime/playerCount));
                    }

                    List<TimeSeriesChartSeries.TimeValue> chartData = new List<TimeSeriesChartSeries.TimeValue>();
                    foreach(var ge in groupEvents)
                    {
                        chartData.Add(new TimeSeriesChartSeries.TimeValue(new DateTime((long)ge.Item1 * 10000), ge.Item2 > maxStack ? maxStack : ge.Item2));
                    }


                    if (_chartDisplayMode != ChartDisplayMode.GraphPerLog && !Series.ContainsKey(Group.ToString()))
                    {
                        Series.Add(Group.ToString(), new List<TimeSeriesChartSeries>());
                    }
                    // List<TimeSeriesChartSeries.TimeValue> chartData = new List<TimeSeriesChartSeries.TimeValue>();
                    // for (long i = Log.GetPhaseStart(_selectedPhase); i < Log.GetPhaseEnd(_selectedPhase); i += 500)
                    // {
                    //     var boonAtTime = (int)Log.GetBoon(Group, _selectedBoon, _selectedPhase, i, duration);
                    //     chartData.Add(new TimeSeriesChartSeries.TimeValue(new DateTime(i*10000), boonAtTime));
                    // }
                    if (_chartDisplayMode == ChartDisplayMode.GraphPerLog)
                    {
                        var chartSeries = new TimeSeriesChartSeries() { Name = Group.ToString(), Data = chartData, Type = TimeSeriesDiplayType.Line };
                        Series[Log.GetFileName()].Add(chartSeries);
                    }
                    else
                    {
                        var chartSeries = new TimeSeriesChartSeries() { Name = Log.GetFileName(), Data = chartData, Type = TimeSeriesDiplayType.Line };
                        Series[Group.ToString()].Add(chartSeries);
                    }
                }
                Console.WriteLine($"Group loop stopwatch {LogParser.GetStopwatchTime()}");
            }
            Options.MaxNumYAxisTicks = maxStack;
            var endTime = Log.GetPhaseEnd(_selectedPhase);
            if (endTime > maxTime)
            {
                maxTime = endTime;
            }
            var startTime = Log.GetPhaseStart(_selectedPhase);
            if (startTime < minTime)
            {
                minTime = startTime;
            }
        }
        if (_chartDisplayMode == ChartDisplayMode.GraphPerLog)
        {
            foreach(var Log in LogParser.BulkLog.Logs)
            {
                var selectedPhaseStart = Log.GetPhaseStart(_selectedPhase);
                var selectedPhaseEnd = Log.GetPhaseEnd(_selectedPhase);
                foreach(var phase in Log.GetPhases())
                {
                    var phaseStart = Log.GetPhaseStart(phase);
                    if (phaseStart < selectedPhaseStart || phaseStart > selectedPhaseEnd)
                    {
                        continue;
                    }
                    var chartData = new List<TimeSeriesChartSeries.TimeValue>() { new TimeSeriesChartSeries.TimeValue(new DateTime((long)phaseStart * 10000), 0), new TimeSeriesChartSeries.TimeValue(new DateTime((long)phaseStart * 10000+1), maxStack) };

                    var chartSeries = new TimeSeriesChartSeries() { Name = phase, Data = chartData, Type = TimeSeriesDiplayType.Line };
                }
            }
        }

        graphTimespan = TimeSpan.FromMilliseconds((maxTime - minTime)/10);
        //Options.YAxisTicks = 5;
        Options.YAxisTicks = 1;
        Options.XAxisLines = true;
        Options.YAxisLines = true;
        Options.YAxisRequireZeroPoint = true;
        Options.ChartPalette = _playerColours.Where(x => _showPlayersDict[x.Key]).Select(x => x.Value).ToArray();

        StateHasChanged();
    }

    private void OnBoonSelectionChanged(string boon){
        _selectedBoon = boon;
        OnNewData();
    }

    protected override void OnInitialized()
    {
        SelectedBoonChanged = EventCallback.Factory.Create<string>(this, OnBoonSelectionChanged);
        ShowPlayersChanged = EventCallback.Factory.Create<bool>(this, UpdateShowPlayers);
        ShowGroupsChanged = EventCallback.Factory.Create<bool>(this, UpdateShowGroups);
        Console.WriteLine("Boons Page Initialized");
        LogParser.NewDataEvent += OnNewData;

    }

    private void UpdateShowPlayer(string player, bool isChecked){
        _showPlayersDict[player] = isChecked;
        OnNewData();
    }

    private void UpdateShowGroup(string group, bool isChecked){
        _showGroupsDict[group] = isChecked;
        OnNewData();
    }

    private void UpdateShowPlayers(bool show){
        _showPlayers = show;
        OnNewData();
    }

    private void UpdateShowGroups(bool show){
        _showGroups = show;
        OnNewData();
    }

    private void SetMode(ChartDisplayMode mode)
    {
        _chartDisplayMode = mode;
        OnNewData();
    }

    private void SetPhase(string text)
    {
        _selectedPhase = text;
        OnNewData();
    }
}
